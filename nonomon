#! /bin/zsh

#TODO: also define $1 and $2 as short versions of file and file_without_extension
# show usage if less than two args were provided
if [[ $# -lt 2 ]]; then
  echo "\
  Usage: nonomon <command> <fileglob> \
    * command: The shell command you want to execute when\
      the target file(s) change. Two shell variables are\
      set before the command is executed:\
        \
      * file: The name of the file which was modified.\
\
      * file_without_extension: The name of the file which\
        was modified, without it's file extension.\
\
    * file glob: The file glob which specifies which files\
      to monitor\
\
    If the command does not include either the file or \
    file_without_extension variables, the name of the modified\
    file will be appended to the command.\
\
    Example without shell variables:\
\
    ./nonomon \"echo File: \" \
"
      
  exit 1
fi

#TODO: we need to do one execution as soon as we start
TMPFILE="/tmp/$(basename $0).$$.tmp"
COMMAND=$1
shift
TARGETS=$@

# echo "The target is:\n $TARGETS"
# echo "The command is: $COMMAND"
# echo "The tmp file is: $TMPFILE"

while true;
do
  echo ">> Watching <<"
  inotifywait -r -e close_write -e move_self \
    --fromfile =(echo $TARGETS | sed 's/ /\n/g') > $TMPFILE 2>&1

  #TODO right now it looks like we only get one file name
  CHANGED_FILES=$(grep -Po '.*(?=MOVE_SELF|CLOSE_WRITE)' $TMPFILE \
    | sed 's/\n/ /g')

  # we assume there is only one file, otherwise this would
  # need to be iterative
  FILE_WITHOUT_EXTENSION="${CHANGED_FILES%.*}"

  echo ">> Executing <<\n"
  # if the command contains $file or $file_without_extension,
  # set $file and execute without appending. Otherwise, don't 
  # set file and append.
  if [[ "${COMMAND%%\$file*}" != $COMMAND ]]; then
    eval "file=$CHANGED_FILES;file_without_extension=$FILE_WITHOUT_EXTENSION; $COMMAND"
  else
    eval "$COMMAND $CHANGED_FILES"
  fi
  echo "\n>> Executed"
done
